\documentclass[12pt, oneside]{book}

\usepackage{graphicx}
%\usepackage{cancel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\usepackage[utf8]{inputenc}
\usepackage[T2A,T1]{fontenc}
\usepackage{ragged2e}

\usepackage{setspace}
\onehalfspacing
\setlength{\parindent}{1.25cm}
%\setstretch{1.8}
\everymath{\displaystyle}
\usepackage{tocloft}
\cftsetindents{section}{1em}{2em}
%\cftsetindents{subsection}{2em}{3em}
\renewcommand\cfttoctitlefont{\hfill\Large\bfseries}
\renewcommand\cftaftertoctitle{\hfill\mbox{}}
\setlength{\cftbeforesecskip}{0.1cm}
\setlength{\cftbeforesubsecskip}{0.1cm}
\setlength{\cftbeforetoctitleskip}{0cm}
\setlength{\cftaftertoctitleskip}{0.4cm}
\setcounter{tocdepth}{2}


\usepackage[english,russian]{babel}
\usepackage[a4paper, left=3cm, top=2cm, right=1.5cm, bottom=2cm]{geometry}

\def\letus{%
    \mathord{\setbox0=\hbox{$\exists$}%
             \hbox{\kern 0.125\wd0%
                   \vbox to \ht0{%
                      \hrule width 0.75\wd0%
                      \vfill%
                      \hrule width 0.75\wd0}%
                   \vrule height \ht0%
                   \kern 0.125\wd0}%
           }%
}

\makeatletter
\renewcommand{\@makeschapterhead}[1]{%
  \vspace*{0\p@}
  {\parindent \z@ \center
    \normalfont
    \LARGE \bfseries #1\par\nobreak
    \addcontentsline{toc}{chapter}{#1}
    \vskip 10\p@
}}
\makeatother

\makeatletter
\renewcommand{\chapter}{%
  \if@openright\cleardoublepage\else\clearpage\fi
  \thispagestyle{plain}
  \global\@topnum\z@
  \@afterindentfalse
  \secdef\@chapter\@schapter}

\renewcommand{\@makechapterhead}[1]{%
  \vspace*{0\p@}
  {\parindent \z@ \raggedright
    \normalfont
    \LARGE \bfseries \thechapter\quad #1\par\nobreak
    \vskip 20\p@
  }}
\makeatother

\makeatletter
\newcommand{\custompagestyle}{%
  \begingroup
  \renewcommand{\ps@plain}{%
    \renewcommand{\@oddfoot}{\hfil\thepage\hfil}
    \renewcommand{\@evenfoot}{\hfil\thepage\hfil}
    \renewcommand{\@oddhead}{}
    \renewcommand{\@evenhead}{}
  }%
  \pagestyle{plain}
}
\makeatother

\iffalse
\renewenvironment{quote}
  {\list{}{\topsep=3pt
           \partopsep=3pt
           \parsep=3pt
           \itemsep=3pt
      10%
   \normalfont\relax
  \item\relax}
  {\endlist}
\fi

\newenvironment{customquote}
  {\list{}{\leftmargin=0pt
          \rightmargin=0pt
          \topsep=0pt
          \partopsep=0pt
          \parsep=2pt
          \itemsep=0pt
        }%
   \normalfont\relax
  \item\relax}
  {\endlist}

\begin{document}
\thispagestyle{empty}
\begin{center}
\textbf{\large САНКТ-ПЕТЕРБУРГСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ} \\[2cm]

\text{\large ОТЧЕТ О НАУЧНО-ИССЛЕДОВАТЕЛЬСКОЙ РАБОТЕ} \\[2cm]

\text{\Large Шаго Павел Евгеньевич} \\[0.3cm]

\text{22.Б07-ПУ, 01.03.02 Прикладная математика и информатика} \\[1cm]

\textbf{\Large Планировщики} \\[3cm]

\text{\large Научный руководитель} \\[0.3cm]
\large{к.ф.-м.н., доцент Корхов В. В.} \\[10cm]
\text{Санкт-Петербург}\\ \today

\end{center}

\newpage
\custompagestyle
\setcounter{page}{2}
\renewcommand{\contentsname}{Содержание}
\tableofcontents

\newpage
\chapter*{Введение}
\begin{quote}
\quad С усложнением систем построенных человеком, появилась
необходимость этими системами управлять. Значительные запросы
на построение таких управляющих механизмов приходят
из автоматизации и компьютеризации.
Так, почти любое современное производство немыслимо
без компьютера или микроконтроллера, который, например,
управляет станком.

\quad Крайне распространено Unix-подобное ядро Linux для
операционных систем (ОС).
Этот компонент содержит огромное количество планировщиков,
среди которых 3 различных реализации планировщика 
потоков (процессов) ОС.
Однако кроме них существуют также
и специализированные решения, например, планировщики
сетевого трафика или ввода-вывода, всего в ядре Linux
содержится более 20 различных планировщиков и более 6 из
них работают постоянно практически на всех системах.

\quad Улучшения планировщиков имеют особую важность, поскольку они
сразу же затрагивают большое число систем которые их используют.
Такие улучшения несомненно приводят к значительному повышению
общей производительности всех систем.

\quad К планировщикам необходимо предъявлять различные требования
в зависимости от задач, которые они выполняют.
Например, при работе с потоками важно учитывать ограничения
необходимые для реализации напрямую взаимодействующих 
с планировщиком клиентов. Так, для реализации сильных семафоров 
необходимо накладывать на планировщик дополнительное условие 
(ограничение) описывающее его работу.
В системах реального времени планировщики 
должны гарантировать выполнение задач в строго определенные 
временные интервалы, что требует высокой предсказуемости и низкой 
задержки при переключении контекста. 
Кроме того, в целом мы стремимся к тому, чтобы планировщики 
обладали минимальными затратами на выполнение (англ. runtime cost) 
и высокой эффективностью, что позволяет оптимально использовать 
доступные ресурсы системы и обеспечивать высокую 
производительность при минимальных затратах.

\quad Настоящая работа посвящена изучению современных подходов
к разработке и оптимизации планировщиков, включая анализ
их преимуществ, недостатков и возможных сфер применения.
Также внимание уделено вопросам моделирования задач
планирования, выбора алгоритмов и оценки их производительности.
\end{quote}

\chapter{Планировщики ОС}
\section{Переключение контекста и роль планировщика}
\begin{quote}
\bf Переключение контекста \normalfont (англ. context switch) ---
это процесс сохранения состояния 
текущего выполняющегося процесса и восстановления состояния
следующего процесса, который будет запущен на выполнение.

Это фундаментальная операция в многозадачных системах, позволяющая
эффективно использовать процессорное время. Однако ключевой вопрос
заключается в том, какой процесс выбрать следующим
для выполнения. 
Ответ на этот вопрос дает алгоритм планирования,
реализуемый в компоненте ядра операционной системы, известном
как планировщик процессов.

Планировщик процессов играет центральную роль в обеспечении
стабильной и эффективной работы операционной системы, особенно
в условиях множества одновременно выполняющихся задач.
Без эффективного планировщика система могла бы столкнуться
с ситуациями, когда одни процессы потребляют непропорционально
много ресурсов, в то время как другие остаются без необходимой
мощности для выполнения своих задач.

В современных операционных системах планировщики постоянно
эволюционируют, интегрируя новые технологии и методы для
улучшения производительности и надежности. Например, адаптивные
алгоритмы планирования могут динамически изменять приоритеты
процессов в зависимости от текущих условий и требований,
обеспечивая более гибкое и эффективное использование ресурсов.

Таким образом, планировщики являются неотъемлемым компонентом
операционных систем, обеспечивая их стабильную работу, высокую
производительность и способность адаптироваться к постоянно
меняющимся условиям эксплуатации.
\end{quote}


\chapter{Алгоритмы планирования}
\section{Алгоритм первый пришел первый вышел (FIFO)}
\begin{quote}
FIFO (First in first out) --- классический метод планирования,
следует принципу «первым пришел --- первым обслужен». Процессы обрабатываются
в порядке их поступления. Этот алгоритм отвечает за
непосредственное распределение процессорного времени между потоками. 
Планировщик определяет, какому потоку и на какой период времени будет выделен
процессор.
Этот уровень также включает координацию выполнения потоков на многоядерных или многопроцессорных системах, обеспечивая эффективное использование аппаратных ресурсов.итм прост в реализации,
но редко применяется в чистом виде, поскольку не учитывает
особенности задач и может приводить к неэффективному использованию
ресурсов. Он лучше всего подходит для длительных, требовательных
к вычислительным ресурсам процессов, которые требуют операций
ввода-вывода.
\end{quote}

\section{Алгоритм кратчайшей работы следующей (SJN)}
\begin{quote}
Алгоритм кратчайшей работы следующей (англ. shortest job next)
выбирает для выполнения тот процесс, который требует наименьшего 
процессорного времени (англ. burst time).
Одной из основных трудностей является оценка времени выполнения процесса,
которая не всегда может быть точной.
Вытесняющая модификация этого алгоритма сортирует процессы
по оставшемуся времени выполнения, позволяя быстро завершать
короткие процессы и эффективно снижать общее время оборота.
\end{quote}

\section{Алгоритм очереди с приоритетами}
\begin{quote}
Приоритетное планирование назначает каждому процессу числовой
приоритет, определяющий его порядок выполнения. Высокий приоритет
(низкое числовое значение) означает более раннее выполнение.
Однако этот метод сталкивается с проблемой старвации (голодания),
когда процессы с низким приоритетом не получают процессорного
времени из-за непрерывного выполнения процессов с высоким
приоритетом. Для решения этой проблемы часто используется механизм
старения, который постепенно повышает приоритет процессов,
долго находящихся в очереди на исполнение.
\end{quote}

\section{Алгоритм Раунд-Робин (RR)}
\begin{quote}
Алгоритм Раунд-Робин (RR) основан на вытесняющей многозадачности и
предоставляет каждому процессу фиксированный квант времени (q)
для выполнения. После истечения этого времени процесс вытесняется
и помещается в конец очереди. Этот метод обеспечивает равномерное
распределение процессорного времени и высокую отзывчивость
системы.

Однако выбор размера кванта времени критичен: слишком большой квант
приводит к поведению, схожему с FIFO, а слишком маленький
увеличивает накладные расходы на переключение контекста.
Также Раунд-Робин может быть неэффективен для процессов
с интенсивным вводом-выводом.
\end{quote}

\section{Алгоритм многоуровневых очередей}
\begin{quote}
Метод многоуровневых очередей классифицирует процессы по различным
критериям и распределяет их по нескольким очередям с разными уровнями приоритетов.
Внутри каждой очереди может применяться свой алгоритм планирования, например,
Раунд-Робин или FIFO. Этот подход обеспечивает гибкость и позволяет
оптимизировать время отклика для критически важных процессов,
одновременно эффективно используя ресурсы для фоновых задач.
\end{quote}

\section{Модификация алгоритма 2.5}
\begin{quote}
Модификация этого метода с обратной связью позволяет динамически
изменять приоритеты процессов на основе их поведения, предотвращая старвацию
и улучшая общую производительность системы. Например, процессы, долго
ожидающие выполнения, могут получать повышение приоритета, а активно работающие
процессы --- понижаться.
\end{quote}

\chapter{Классификация планировщиков}
\section{Пакетные планировщики}
\begin{quote}
Пакетные планировщики предназначены для выполнения длительных задач,
требующих значительных вычислительных ресурсов. Частые прерывания процессов
в таких планировщиках не предусмотрены, что позволяет эффективно
использовать процессорное время для интенсивных вычислений.
\end{quote}

\section{Интерактивные планировщики}
\begin{quote}
Интерактивные планировщики стремятся минимизировать время отклика,
обеспечивая отзывчивость пользовательского интерфейса на действия пользователя,
такие как перемещение курсора мыши или нажатие клавиш. Это особенно важно
для персональных компьютеров, где скорость реакции системы напрямую влияет
на удобство и эффективность работы.
\end{quote}

\section{Планировщики реального времени}
\begin{quote}
Планировщики реального времени разработаны для систем, требующих
соблюдения временных рамок выполнения задач (дедлайнов). Они часто используются
в критически важных приложениях, где нарушение временных ограничений может
привести к серьезным последствиям. В таких системах первостепенным является
соблюдение дедлайнов, а другие показатели, такие как время отклика,
могут быть менее значимыми.
\end{quote}

\chapter{Уровни планирования}
\section{Долгосрочное планирование}
\begin{quote}
На долгосрочном уровне принимается решение о том, какие новые задачи
будут добавлены в систему для исполнения. Это включает управление
загрузкой задач в систему и контроль за количеством активных процессов.
\end{quote}

\section{Среднесрочное планирование}
\begin{quote}
Среднесрочное планирование занимается управлением памятью, определяя,
какие программы временно выгрузить во вторичную память для
оптимизации доступного пространства и повышения эффективности работы системы.
\end{quote}

\section{Краткосрочное планирование}
\begin{quote}
Краткосрочное планирование отвечает за непосредственное распределение
процессорного времени между потоками. Планировщик определяет, какому потоку
и на какой период времени будет выделен процессор. Этот уровень также включает
координацию выполнения потоков на многоядерных или многопроцессорных системах,
обеспечивая эффективное использование аппаратных ресурсов.
\end{quote}

\chapter{Метрики планирования}
\section{Время поступления $ T_A $}
\begin{quote}
Время поступления процесса --- момент, когда процесс становится готовым
к выполнению.
\end{quote}

\section{Время ожидания $ T_W $}
\begin{quote}
Время ожидания представляет собой период, в течение которого процесс
ожидает возможности быть обработанным центральным процессором.
\end{quote}

\section{Время выполнения $ T_S $}
\begin{quote}
Время выполнения --- период, в течение которого процесс
активно исполняется на процессоре.
\end{quote}

\section{Время оборота $ T_R $}
\begin{quote}
Время оборота включает в себя общее время, затраченное процессом в системе,
включая периоды ожидания и активного выполнения.
\end{quote}

\section{Пример оценки метрик}
\begin{quote}
Рассмотрим пример для иллюстрации важности выбора порядка выполнения процессов.
Допустим, одновременно поступают три процесса с различным временем выполнения.

$ \letus $ есть 3 процесса и их burst (время исполнения одного процесса) 

$ T_{BURST_1} = 30,\ T_{BURST_2} = 5,\ T_{BURST_3} = 5 $

Если мы будем выпонять сначала 1 потом 2 потом 3, то

$ T_{W_1} = 0,\ T_{W_2} = 30,\ T_{W_3} = 35 \implies 
T_{W_{AVG}} = 21 \frac{2}{3} $

А выполнять по порядку 3, 2, 1, то

$ T_{W_3} = 0,\ T_{W_2} = 5,\ T_{W_1} = 10 \implies T_{W_{AVG}} = 5 $

Таким образом видим, что изменение порядка выполнения может значительно
снизить среднее время ожидания.
\end{quote}


\chapter{Реализации планировщиков потоков в Linux}
\section{Brain Fuck Scheduler (BFS)}
\begin{quote}
BFS был разработан Кон Коливасом в 2009 году как альтернативный
планировщик для ядра Linux, его задача предоставить планировщик
с более простым алгоритмом, который не требует настройки эвристики
или параметров настройки (англ. tuning parameters) для адаптации
производительности к определенному типу вычислительной нагрузки.
Коливас утверждал, что эти настраиваемые параметры сложны для
понимания обычным пользователем, особенно в плане взаимодействия
нескольких параметров друг с другом, и заявлял, что использование
таких параметров настройки часто может привести к улучшению
производительности в конкретном целевом типе вычислений
ценой ухудшения производительности в общем случае.

BFS улучшает отзывчивость на настольных компьютерах Linux с менее
чем 16 ядрами. В отличие от других планировщиков, BFS использует
единую глобальную очередь для всех процессов, что упрощает управление
и устраняет необходимость в сложных
механизмах балансировки нагрузки между процессорами (ядрами).

Каждому процессу присваивается виртуальный дедлайн,
рассчитываемый на основе текущего времени, приоритета процесса
и фиксированного интервала времени. 
Это позволяет планировщику определять порядок выполнения задач,
отдавая предпочтение процессам с более ранними дедлайнами.
\end{quote}

\section{Completely Fair Scheduler (CFS)}
\begin{quote}
CFS был разработан венгерским программистом из компании Red Hat
Инго Молнаром и был включен в ядро Linux начиная с версии 2.6.23.
Этот планировщик ориентирован на задачи класса SHED\_NORMAL 
(т.е. на задачи, не имеющие ограничений на выполнение в реальном времени).
CFS старается максимизировать две характеристики: использование процессора 
(ядер процессора) и интерактивную производительность.

В отличие от предыдущего планировщика O(1), использовавшегося в версиях
ядра Linux 2.6, который поддерживал и переключал очереди выполнения
активных и истекших задач, реализация планировщика CFS основана на
очередях выполнения на каждом процессоре (ядре), узлами которых являются
упорядоченные по времени планируемые объекты, которые хранятся
отсортированными в виде красно-черных деревьев. CFS отказывается от
старого понятия фиксированных временных срезов с определенными
приоритетами и вместо этого стремится предоставить справедливую
долю процессорного времени планируемым сущностям.

\bf Планируемая сущность \normalfont (англ. task) ---
минимальный объект который может
спланировать ядро Linux. Однако ядро также может управлять группами
потоков, целыми многопоточными процессами и даже всеми процессами
определенного пользователя. Такая конструкция приводит к концепции
планируемых объектов, где задачи группируются и управляются
планировщиком как единое целое. Для того чтобы эта конструкция работала,
каждый дескриптор задачи task\_struct содержит поле типа sched\_entity,
которое представляет группу планирования к которой принадлежит эта задача.

Каждая очередь типа cfs\_rq на каждом процессоре (ядре) сортирует
структуры sched\_entity по времени в красно-черное дерево 
(или <<rbtree>> на языке Linux), где самый левый узел занимает группа,
получившая наименьший кусок времени выполнения 
(который сохраняется в поле vruntime сущности).
Узлы индексируются по времени выполнения процессором в наносекундах.
Для каждого процесса также рассчитывается максимальное время выполнения,
представляющее собой время, в течение которого процесс должен был
бы выполняться на идеальном процессоре.
Это время, в течение которого процесс ожидал запуска,
деленное на общее количество процессов.

Когда планировщик вызывается для запуска нового процесса 
происходит следующая последовательность действий:

1. Выбирается самый левый узел дерева планирования 
(так как он будет иметь наименьшее время выполнения)
и отправляется на выполнение.

2. Если процесс просто завершает выполнение, он удаляется из системы
и дерева планирования.

3. Если процесс достигает своего максимального времени выполнения
или иным образом останавливается (добровольно или через прерывание),
он снова вставляется в дерево планирования на основе его нового
затраченного времени выполнения.

4. Из дерева выбирается новый крайний левый узел, и итерация повторяется.

Если процесс проводит большую часть времени в состоянии сна,
то значение затраченного времени будет низким, и он автоматически
получит повышение приоритета, когда ему это понадобится.
Следовательно, такие задачи не получают меньше процессорного времени,
чем постоянно выполняющиеся.

Сложность алгоритма, который вставляет узлы в очередь выполнения cfs\_rq
планировщика CFS, составляет $ O(log N) $, где $ N $ -- общее количество
групп. Выбор следующего объекта для запуска осуществляется за
постоянное время, поскольку самый левый узел всегда находится в кэше.
\end{quote}

\section{Earliest eligible virtual deadline first (EEVDF)}
\begin{quote}
Начиная с версии ядра Linux 6.6 (29 октября 2023 года) CFS заменен
(в качестве стандартного планировщика) на планировщик EEVDF.

Впервые был описан в статье 1995 года
<<Earliest Eligible Virtual Deadline First>>, 
написанной Ионом Стоикой и Хусейном Абдель-Вахабом.
EEVDF использует понятия виртуального времени, подходящего времени,
виртуальных запросов и виртуальных сроков для определения приоритета
планирования. Также обладает свойством, что когда планируемая сущность
продолжает запрашивать обслуживание, объем полученного обслуживания
всегда находится в пределах максимального квантового размера,
на который сущность имеет право.

Подробно EEVDF в данной работе не разбирается, в целом этот планировщик
достаточно похож на BFS. 
\end{quote}

\chapter{Планирование в пользовательском пространстве}
\section{Введение}
\begin{quote}
Несмотря на все усилия разработчиков ОС иногда бывает полезно
построить свой планировщик который будет работать в пользовательском
пространстве и использовать собственные модели, например, для более
эффективного переключения между потоками в сетевых задачах.
\end{quote}

\section{Планировщик в Go}
\begin{quote}
\bf Горутина \normalfont (англ. goroutine) --- легковесный 
(по сравнению с планируемой сущностью) поток, управляемый планировщиком
рантайма языка Go.
Планировщик Go основан на модели M:N 
(M горутин на N потоках ОС) и использует следующие ключевые компоненты:

1. G (Goroutine): Представляет собой структуру, описывающую горутину,
включая её стек, состояние и другие метаданные.

2. M (Machine): Соответствует потоку ОС. M выполняет горутины.

3. P (Processor): Представляет собой контекст выполнения,
необходимый для выполнения горутин, включая локальные очереди горутин
и управление ресурсами.

При запуске программы Go (рантайм языка) инициализирует пул P контекстов,
количество которых определяется переменной GOMAXPROCS.
По умолчанию GOMAXPROCS устанавливается равным количеству доступных
ядер процессора, но это значение может быть изменено пользователем.

Далее работа планировщика описывается следующей последовательностью:
1. Создание горутин: При создании новой горутины она помещается
в очередь готовых задач (англ. run queue).

2. Выбор P: Планировщик выбирает P для выполнения горутины.
Обычно используется локальная очередь P для минимизации синхронизации.

3. Назначение M: Каждому P назначается M. Если все M заняты, новые M
создаются по мере необходимости до достижения GOMAXPROCS.

4. Выполнение: M выполняет горутину, извлекая её из очереди P.
При завершении горутина освобождается, и M может перейти
к следующей задаче.

\end{quote}

\chapter*{Заключение}
\begin{quote}
\quad В данной работе были рассмотрены основные подходы и алгоритмы
планирования в операционных системах и пользовательском пространстве,
их реализации в различных контекстах.
Были проанализировали ключевые аспекты планировщиков, такие как роль 
переключения контекста, особенности алгоритмов планирования.
Особое внимание было уделено планировщикам, реализованным в ядре Linux.

\quad В контексте развития вычислительных систем и повышения требований
к их производительности и отзывчивости, результаты данной работы
формируют важный теоретический и прикладной фундамент для дальнейших
исследований. Они подчеркивают ключевые аспекты, такие как минимизация
задержек, равномерное распределение ресурсов и снижение сложности
настройки планировщиков, что является важным для построения
высокоэффективных и адаптивных систем.

\quad Таким образом, проведённое исследование не только предоставляет
всесторонний анализ существующих решений, но и намечает направления
для совершенствования планировщиков. В будущем планируется уделить 
внимание дальнейшей интеграции планировщиков с адаптивными алгоритмами 
что обеспечит ещё более высокую производительность и стабильность систем.
Это позволит решать актуальные задачи, стоящие перед современными
вычислительными средами, и повысить эффективность их работы в различных
сферах.
\end{quote}


\renewcommand{\bibname}{\large СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ}
\begin{thebibliography}{9}
  \vspace*{0.3cm}
  \bibitem{1}
  Joseph Y-T. Leung\ Handbook of Scheduling: Algorithms, Models, and Performance Analysis CRC Press 2004
  \bibitem{2}
  Andrew S. Tanenbaum, Herbert Bos\ MODERN OPERATING SYSTEMS Pearson
  Education 2023
  \bibitem{3}
  Dror G. Feitelson, Larry Rudolph\ Job Scheduling
  Strategies for Parallel Processing Springer 2001
  \bibitem{4}
  William Stallings\ Operating Systems: Internals and
  Design Principles Pearson Education 2020
  \bibitem{5}
  Michael J. Morrison\ Resource Management and Scheduling
  in Multitasking Operating Systems CRC Press 2017
  \bibitem{6}
  Arden Durell\ Go Scheduler Internals 2018
  \bibitem{7}
  Thomas E. Anderson, Brian N. Bershad, Edward D. Lazowska, 
  Henry M. Levy\ Scheduler activations: effective kernel
  support for the user-level management of parallelism ACM 1992
  \bibitem{8}
  Xiaomin Zhu, Yabing Zha, Ling Liu, Peng JiaoGeneral\
  Framework for Task Scheduling and Resource Provisioning
  in Cloud Computing Systems IEEE 2016
\end{thebibliography}

\end{document}
