\documentclass[12pt, oneside]{book}

\usepackage{graphicx}
%\usepackage{cancel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\usepackage[utf8]{inputenc}
\usepackage[T2A,T1]{fontenc}
\usepackage{ragged2e}

\usepackage{setspace}
\onehalfspacing
\setlength{\parindent}{1.25cm}
%\setstretch{1.8}
\everymath{\displaystyle}
\usepackage{tocloft}
\cftsetindents{section}{1em}{2em}
%\cftsetindents{subsection}{2em}{3em}
\renewcommand\cfttoctitlefont{\hfill\Large\bfseries}
\renewcommand\cftaftertoctitle{\hfill\mbox{}}
\setlength{\cftbeforesecskip}{0.1cm}
\setlength{\cftbeforesubsecskip}{0.1cm}
\setlength{\cftbeforetoctitleskip}{0cm}
\setlength{\cftaftertoctitleskip}{0.4cm}
\setcounter{tocdepth}{2}


\usepackage[english,russian]{babel}
\usepackage[a4paper, left=3cm, top=2cm, right=1.5cm, bottom=2cm]{geometry}

\def\letus{%
    \mathord{\setbox0=\hbox{$\exists$}%
             \hbox{\kern 0.125\wd0%
                   \vbox to \ht0{%
                      \hrule width 0.75\wd0%
                      \vfill%
                      \hrule width 0.75\wd0}%
                   \vrule height \ht0%
                   \kern 0.125\wd0}%
           }%
}

\makeatletter
\renewcommand{\@makeschapterhead}[1]{%
  \vspace*{0\p@}
  {\parindent \z@ \center
    \normalfont
    \LARGE \bfseries #1\par\nobreak
    \addcontentsline{toc}{chapter}{#1}
    \vskip 10\p@
}}
\makeatother

\makeatletter
\renewcommand{\chapter}{%
  \if@openright\cleardoublepage\else\clearpage\fi
  \thispagestyle{plain}
  \global\@topnum\z@
  \@afterindentfalse
  \secdef\@chapter\@schapter}

\renewcommand{\@makechapterhead}[1]{%
  \vspace*{0\p@}
  {\parindent \z@ \raggedright
    \normalfont
    \LARGE \bfseries \thechapter\quad #1\par\nobreak
    \vskip 20\p@
  }}
\makeatother

\makeatletter
\newcommand{\custompagestyle}{%
  \begingroup
  \renewcommand{\ps@plain}{%
    \renewcommand{\@oddfoot}{\hfil\thepage\hfil}
    \renewcommand{\@evenfoot}{\hfil\thepage\hfil}
    \renewcommand{\@oddhead}{}
    \renewcommand{\@evenhead}{}
  }%
  \pagestyle{plain}
}
\makeatother

\iffalse
\renewenvironment{quote}
  {\list{}{\topsep=3pt
           \partopsep=3pt
           \parsep=3pt
           \itemsep=3pt
      10%
   \normalfont\relax
  \item\relax}
  {\endlist}
\fi

\newenvironment{customquote}
  {\list{}{\leftmargin=0pt
          \rightmargin=0pt
          \topsep=0pt
          \partopsep=0pt
          \parsep=2pt
          \itemsep=0pt
        }%
   \normalfont\relax
  \item\relax}
  {\endlist}

\begin{document}
\thispagestyle{empty}
\begin{center}
\textbf{\large САНКТ-ПЕТЕРБУРГСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ} \\[2cm]

\text{\large ОТЧЕТ О НАУЧНО-ИССЛЕДОВАТЕЛЬСКОЙ РАБОТЕ} \\[2cm]

\text{\Large Шаго Павел Евгеньевич} \\[0.3cm]

\text{22.Б07-ПУ, 01.03.02 Прикладная математика и информатика} \\[1cm]

\textbf{\Large Планировщики} \\[3cm]

\text{\large Научный руководитель} \\[0.3cm]
\large{к.ф.-м.н., доцент Корхов В. В.} \\[10cm]
\text{Санкт-Петербург}\\ \today

\end{center}

\newpage
\custompagestyle
\setcounter{page}{1}
\renewcommand{\contentsname}{Содержание}
\tableofcontents

\newpage
\chapter*{Введение}
\begin{quote}
\quad С усложнением систем построенных человеком, появилась
необходимость этими системами управлять. Значительные запросы
на построение таких управляющих механизмов приходят
из автоматизации и компьютеризации.
Так, почти любое современное производство немыслимо
без компьютера или микроконтроллера, который, например,
управляет станком.

\quad Крайне распространено Unix-подобное ядро Linux для
операционных систем (ОС).
Этот компонент содержит огромное количество планировщиков,
среди которых 3 различных реализации планировщика 
потоков (процессов) ОС.
Однако кроме них существуют также
и специализированные решения, например, планировщики
сетевого трафика или ввода-вывода, всего в ядре Linux
содержится более 20 различных планировщиков и более 6 из
них работают постоянно практически на всех системах.

\quad Улучшения планировщиков имеют особую важность, поскольку они
сразу же затрагивают большое число систем которые их используют.
Такие улучшения несомненно приводят к значительному повышению
общей производительности всех систем.

\quad К планировщикам необходимо предъявлять различные требования
в зависимости от задач, которые они выполняют.
Например, при работе с потоками важно учитывать ограничения
необходимые для реализации напрямую взаимодействующих 
с планировщиком клиентов. Так, для реализации сильных семафоров 
необходимо накладывать на планировщик дополнительное условие 
(ограничение) описывающее его работу.
В системах реального времени планировщики 
должны гарантировать выполнение задач в строго определенные 
временные интервалы, что требует высокой предсказуемости и низкой 
задержки при переключении контекста. 
Кроме того, в целом мы стремимся к тому, чтобы планировщики 
обладали минимальными затратами на выполнение (англ. runtime cost) 
и высокой эффективностью, что позволяет оптимально использовать 
доступные ресурсы системы и обеспечивать высокую 
производительность при минимальных затратах.

\quad Настоящая работа посвящена изучению современных подходов
к разработке и оптимизации планировщиков, включая анализ
их преимуществ, недостатков и возможных сфер применения.
Основное внимание уделено вопросам моделирования задач
планирования, выбора алгоритмов и оценки их производительности.
\end{quote}

\chapter{Планировщики ОС}
\section{Переключение контекста и роль планировщика}
\begin{quote}
\quad \bf Переключение контекста \normalfont (англ. context switch) ---
это процесс сохранения состояния 
текущего выполняющегося процесса и восстановления состояния
следующего процесса, который будет запущен на выполнение.

\quad Это фундаментальная операция в многозадачных системах, позволяющая
эффективно использовать процессорное время. Однако ключевой вопрос
заключается в том, какой процесс выбрать следующим
для выполнения. 
Ответ на этот вопрос дает алгоритм планирования,
реализуемый в компоненте ядра операционной системы, известном
как планировщик процессов.
\end{quote}


\chapter{Алгоритмы планирования}
\section{Алгоритм первый пришел первый вышел (FIFO)}
\begin{quote}
\quad FIFO (First in first out) --- классический метод планирования,
следует принципу «первым пришел --- первым обслужен». Процессы обрабатываются
в порядке их поступления. Этот алгоритм отвечает за
непосредственное распределение процессорного времени между потоками. 
Планировщик определяет, какому потоку и на какой период времени будет выделен
процессор.
Этот уровень также включает координацию выполнения потоков на многоядерных или многопроцессорных системах, обеспечивая эффективное использование аппаратных ресурсов.итм прост в реализации,
но редко применяется в чистом виде, поскольку не учитывает
особенности задач и может приводить к неэффективному использованию
ресурсов. Он лучше всего подходит для длительных, требовательных
к вычислительным ресурсам процессов, которые требуют операций
ввода-вывода.
\end{quote}

\section{Алгоритм кратчайшей работы следующей (SJN)}
\begin{quote}
\quad Алгоритм кратчайшей работы следующей (англ. shortest job next)
выбирает для выполнения тот процесс, который требует наименьшего 
процессорного времени (англ. burst time).
Одной из основных трудностей является оценка времени выполнения процесса,
которая не всегда может быть точной.
Вытесняющая модификация этого алгоритма сортирует процессы
по оставшемуся времени выполнения, позволяя быстро завершать
короткие процессы и эффективно снижать общее время оборота.
\end{quote}

\section{Алгоритм очереди с приоритетами}
\begin{quote}
\quad Приоритетное планирование назначает каждому процессу числовой
приоритет, определяющий его порядок выполнения. Высокий приоритет
(низкое числовое значение) означает более раннее выполнение.
Однако этот метод сталкивается с проблемой старвации (голодания),
когда процессы с низким приоритетом не получают процессорного
времени из-за непрерывного выполнения процессов с высоким
приоритетом. Для решения этой проблемы часто используется механизм
старения, который постепенно повышает приоритет процессов,
долго находящихся в очереди на исполнение.
\end{quote}

\section{Алгоритм Раунд-Робин (RR)}
\begin{quote}
\quad Алгоритм Round Robin (RR) основан на вытесняющей многозадачности и
предоставляет каждому процессу фиксированный квант времени (q)
для выполнения. После истечения этого времени процесс вытесняется
и помещается в конец очереди. Этот метод обеспечивает равномерное
распределение процессорного времени и высокую отзывчивость
системы.

\quad Однако выбор размера кванта времени критичен: слишком большой квант
приводит к поведению, схожему с FIFO, а слишком маленький
увеличивает накладные расходы на переключение контекста.
Также Раунд-Робин может быть неэффективен для процессов
с интенсивным вводом-выводом.
\end{quote}

\section{Алгоритм многоуровневых очередей}
\begin{quote}
\quad Метод многоуровневых очередей классифицирует процессы по различным
критериям и распределяет их по нескольким очередям с разными уровнями приоритетов.
Внутри каждой очереди может применяться свой алгоритм планирования, например,
Раунд-Робин или FIFO. Этот подход обеспечивает гибкость и позволяет
оптимизировать время отклика для критически важных процессов,
одновременно эффективно используя ресурсы для фоновых задач.
\end{quote}

\section{Модификация алгоритма 2.5}
\begin{quote}
\quad Модификация этого метода с обратной связью позволяет динамически
изменять приоритеты процессов на основе их поведения, предотвращая старвацию
и улучшая общую производительность системы. Например, процессы, долго
ожидающие выполнения, могут получать повышение приоритета, а активно работающие
процессы --- понижаться.
\end{quote}

\chapter{Классификация планировщиков}
\section{Пакетные планировщики}
\begin{quote}
Пакетные планировщики предназначены для выполнения длительных задач,
требующих значительных вычислительных ресурсов. Частые прерывания процессов
в таких планировщиках не предусмотрены, что позволяет эффективно
использовать процессорное время для интенсивных вычислений.
\end{quote}

\section{Интерактивные планировщики}
\begin{quote}
Интерактивные планировщики стремятся минимизировать время отклика,
обеспечивая отзывчивость пользовательского интерфейса на действия пользователя,
такие как перемещение курсора мыши или нажатие клавиш. Это особенно важно
для персональных компьютеров, где скорость реакции системы напрямую влияет
на удобство и эффективность работы.
\end{quote}

\section{Планировщики реального времени}
\begin{quote}
Планировщики реального времени разработаны для систем, требующих
соблюдения временных рамок выполнения задач (дедлайнов). Они часто используются
в критически важных приложениях, где нарушение временных ограничений может
привести к серьезным последствиям. В таких системах первостепенным является
соблюдение дедлайнов, а другие показатели, такие как время отклика,
могут быть менее значимыми.
\end{quote}

\chapter{Уровни планирования}
\section{Долгосрочное планирование}
\begin{quote}
На долгосрочном уровне принимается решение о том, какие новые задачи
будут добавлены в систему для исполнения. Это включает управление
загрузкой задач в систему и контроль за количеством активных процессов.
\end{quote}

\section{Среднесрочное планирование}
\begin{quote}
Среднесрочное планирование занимается управлением памятью, определяя,
какие программы временно выгрузить во вторичную память для
оптимизации доступного пространства и повышения эффективности работы системы.
\end{quote}

\section{Краткосрочное планирование}
\begin{quote}
Краткосрочное планирование отвечает за непосредственное распределение
процессорного времени между потоками. Планировщик определяет, какому потоку
и на какой период времени будет выделен процессор. Этот уровень также включает
координацию выполнения потоков на многоядерных или многопроцессорных системах,
обеспечивая эффективное использование аппаратных ресурсов.
\end{quote}

\chapter{Метрики планирования}
\section{Время поступления $ T_A $}
\begin{quote}
Время поступления процесса --- момент, когда процесс становится готовым
к выполнению.
\end{quote}

\section{Время ожидания $ T_W $}
\begin{quote}
Время ожидания представляет собой период, в течение которого процесс
ожидает возможности быть обработанным центральным процессором.
\end{quote}

\section{Время выполнения $ T_S $}
\begin{quote}
Время выполнения --- период, в течение которого процесс
активно исполняется на процессоре.
\end{quote}

\section{Время оборота $ T_R $}
\begin{quote}
Время оборота включает в себя общее время, затраченное процессом в системе,
включая периоды ожидания и активного выполнения.
\end{quote}

\section{Пример оценки метрик}
\begin{quote}
Рассмотрим пример для иллюстрации важности выбора порядка выполнения процессов.
Допустим, одновременно поступают три процесса с различным временем выполнения.

$ \letus $ есть 3 процесса и их burst (время исполнения одного процесса) 

$ T_{BURST_1} = 30,\ T_{BURST_2} = 5,\ T_{BURST_3} = 5 $

Если мы будем выпонять сначала 1 потом 2 потом 3, то

$ T_{W_1} = 0,\ T_{W_2} = 30,\ T_{W_3} = 35 \implies 
T_{W_{AVG}} = 21 \frac{2}{3} $

А выполнять по порядку 3, 2, 1, то

$ T_{W_3} = 0,\ T_{W_2} = 5,\ T_{W_1} = 10 \implies T_{W_{AVG}} = 5 $

Таким образом видим, что изменение порядка выполнения может значительно
снизить среднее время ожидания.
\end{quote}


\chapter{Реализации планировщиков потоков в Linux}
\section{BFS (Brain Fuck Scheduler)}
\begin{quote}
BFS был разработан Кон Коливасом в 2009 году как альтернативный планировщик
для ядра Linux, его задача предоставить планировщик с более простым алгоритмом,
который не требует настройки эвристики или параметров настройки 
(англ. tuning parameters) для адаптации производительности к определенному
типу вычислительной нагрузки.
Коливас утверждал, что эти настраиваемые параметры сложны для понимания обычным
пользователем, особенно в плане взаимодействия нескольких параметров друг
с другом, и заявлял, что использование таких параметров настройки часто может
привести к улучшению производительности в конкретном целевом типе вычислений
ценой ухудшения производительности в общем случае ориентированный на уменьшение
задержек и повышение отзывчивости системы, особенно в системах с однопоточными
процессорами и низкими задержками.

BFS улучшает отзывчивость на настольных компьютерах Linux с менее чем 16 ядрами.
В отличие от других планировщиков, BFS использует единую глобальную очередь
для всех процессов, что упрощает управление и устраняет необходимость в сложных
механизмах балансировки нагрузки между процессорами.

Каждому процессу присваивается виртуальный дедлайн, рассчитываемый на основе
текущего времени, приоритета процесса и фиксированного интервала времени. 
Это позволяет планировщику определять порядок выполнения задач,
отдавая предпочтение процессам с более ранними дедлайнами.
\end{quote}

\section{CFS (Completely Fair Scheduler)}
\begin{quote}

\end{quote}

\chapter{Планирование в пользовательском пространстве}
\section{Планировщик в Go}

\section{Планировщик в userver}



\chapter*{Заключение}


\renewcommand{\bibname}{\large СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ}
\begin{thebibliography}{9}
  \vspace*{0.3cm}
  \bibitem{1}
  Joseph Y-T. Leung\ Handbook of Scheduling: Algorithms, Models, and Performance Analysis CRC Press 2004
  \bibitem{2}
  Andrew S. Tanenbaum, Herbert Bos\ MODERN OPERATING SYSTEMS Pearson
  Education 2023
  \bibitem{3}
  Dror G. Feitelson, Larry Rudolph\ Job Scheduling
  Strategies for Parallel Processing Springer 2001
  \bibitem{4}
  William Stallings\ Operating Systems: Internals and
  Design Principles Pearson Education 2020
  \bibitem{5}
  Michael J. Morrison\ Resource Management and Scheduling
  in Multitasking Operating Systems CRC Press 2017
  \bibitem{6}
  Arden Durell\ Go Scheduler Internals 2018
  \bibitem{7}
  Thomas E. Anderson, Brian N. Bershad, Edward D. Lazowska, 
  Henry M. Levy\ Scheduler activations: effective kernel
  support for the user-level management of parallelism ACM 1992
  \bibitem{8}
  Xiaomin Zhu, Yabing Zha, Ling Liu, Peng JiaoGeneral\
  Framework for Task Scheduling and Resource Provisioning
  in Cloud Computing Systems IEEE 2016
\end{thebibliography}

\end{document}
